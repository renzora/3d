<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Babylon.js 3D Engine</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
        }
        #canvas {
            display: block;
            width: 100%;
            height: 100%;
            touch-action: none;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-family: system-ui, sans-serif;
            font-size: 18px;
        }
        #error {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #f44;
            font-family: system-ui, sans-serif;
            font-size: 16px;
            max-width: 600px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 8px;
            display: none;
        }
        #stats {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #fff;
            font-family: monospace;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 4px;
            pointer-events: none;
        }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            margin-top: 100px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 100;
        }
        #controls button, #controls .file-label {
            background: rgba(60, 120, 200, 0.8);
            color: #fff;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-family: system-ui, sans-serif;
            font-size: 13px;
            display: block;
            text-align: center;
        }
        #controls button:hover, #controls .file-label:hover {
            background: rgba(80, 140, 220, 0.9);
        }
        #controls input[type="file"] {
            display: none;
        }

        #panel {
            position: absolute;
            top: 10px;
            right: 10px;
            bottom: 10px;
            width: 280px;
            background: rgba(20, 20, 25, 0.95);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            font-family: system-ui, sans-serif;
            font-size: 13px;
            color: #fff;
            overflow: hidden;
            z-index: 100;
        }
        .tabs {
            display: flex;
            background: rgba(0, 0, 0, 0.3);
            border-bottom: 1px solid #333;
            flex-shrink: 0;
        }
        .tab {
            flex: 1;
            padding: 10px 5px;
            text-align: center;
            cursor: pointer;
            border: none;
            background: transparent;
            color: #888;
            font-size: 11px;
            font-family: system-ui, sans-serif;
            transition: all 0.2s;
        }
        .tab:hover {
            color: #aaa;
            background: rgba(255, 255, 255, 0.05);
        }
        .tab.active {
            color: #8cf;
            background: rgba(100, 150, 255, 0.1);
            border-bottom: 2px solid #8cf;
        }
        .tab-content {
            display: none;
            padding: 15px;
            overflow-y: auto;
            flex: 1;
        }
        .tab-content.active {
            display: block;
        }
        .tab-content::-webkit-scrollbar {
            width: 6px;
        }
        .tab-content::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
        }
        .tab-content::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 3px;
        }
        .section {
            margin-bottom: 15px;
        }
        .section h3 {
            font-size: 12px;
            color: #8cf;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .section label {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 8px 0;
        }
        .section input[type="range"] {
            flex: 1;
            max-width: 100px;
        }
        .section input[type="checkbox"] {
            width: 16px;
            height: 16px;
        }
        .section select {
            flex: 1;
            max-width: 100px;
            background: #333;
            color: #fff;
            border: 1px solid #444;
            padding: 4px;
            border-radius: 3px;
        }
        .section input[type="color"] {
            width: 50px;
            height: 24px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }
        .value {
            width: 40px;
            text-align: right;
            color: #8f8;
            font-size: 12px;
        }
        .divider {
            border: none;
            border-top: 1px solid #333;
            margin: 15px 0;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="loading">Loading Babylon.js Engine...</div>
    <div id="error"></div>
    <div id="stats"></div>
    <div id="controls">
        <label class="file-label" for="model-input">Load Model</label>
        <input type="file" id="model-input" accept=".glb,.gltf,.obj,.babylon">
        <button id="clear-btn">Clear Models</button>
        <button id="demo-btn">Add Demo</button>
    </div>

    <div id="panel">
        <div class="tabs">
            <button class="tab active" data-tab="lighting">Lighting</button>
            <button class="tab" data-tab="effects">Effects</button>
            <button class="tab" data-tab="aa">AA</button>
            <button class="tab" data-tab="scene">Scene</button>
        </div>

        <!-- Lighting Tab -->
        <div class="tab-content active" id="tab-lighting">
            <div class="section">
                <h3>Render Mode</h3>
                <label>
                    Mode
                    <select id="render-mode">
                        <option value="0" selected>Lit</option>
                        <option value="1">Unlit</option>
                        <option value="2">Normals</option>
                        <option value="3">Depth</option>
                        <option value="4">Wireframe</option>
                    </select>
                </label>
            </div>
            <hr class="divider">
            <div class="section">
                <h3>Day/Night Cycle</h3>
                <label>
                    <input type="checkbox" id="daynight-enabled">
                    Auto Cycle
                </label>
                <label>
                    Speed
                    <input type="range" id="daynight-speed" min="0.1" max="5" step="0.1" value="1.0">
                    <span class="value" id="daynight-speed-val">1.0</span>
                </label>
                <label>
                    Time of Day
                    <input type="range" id="daynight-time" min="0" max="1" step="0.01" value="0.5">
                    <span class="value" id="daynight-time-val">12:00</span>
                </label>
            </div>
            <hr class="divider">
            <div class="section">
                <h3>Bloom</h3>
                <label>
                    <input type="checkbox" id="bloom-enabled" checked>
                    Enable
                </label>
                <label>
                    Intensity
                    <input type="range" id="bloom-intensity" min="0" max="2" step="0.1" value="0.8">
                    <span class="value" id="bloom-intensity-val">0.8</span>
                </label>
                <label>
                    Threshold
                    <input type="range" id="bloom-threshold" min="0" max="1" step="0.05" value="0.6">
                    <span class="value" id="bloom-threshold-val">0.6</span>
                </label>
            </div>
            <hr class="divider">
            <div class="section">
                <h3>Tonemapping</h3>
                <label>
                    Exposure
                    <input type="range" id="exposure" min="0.5" max="3" step="0.1" value="1.5">
                    <span class="value" id="exposure-val">1.5</span>
                </label>
                <label>
                    Operator
                    <select id="tonemap-operator">
                        <option value="0">None</option>
                        <option value="1">Reinhard</option>
                        <option value="2" selected>ACES</option>
                    </select>
                </label>
            </div>
            <hr class="divider">
            <div class="section">
                <h3>Vignette</h3>
                <label>
                    <input type="checkbox" id="vignette-enabled" checked>
                    Enable
                </label>
                <label>
                    Weight
                    <input type="range" id="vignette-weight" min="0" max="3" step="0.1" value="1.5">
                    <span class="value" id="vignette-weight-val">1.5</span>
                </label>
            </div>
            <hr class="divider">
            <div class="section">
                <h3>Hemisphere Light</h3>
                <label>
                    <input type="checkbox" id="hemisphere-enabled" checked>
                    Enable
                </label>
                <label>
                    Sky Color
                    <input type="color" id="hemisphere-sky-color" value="#99bfff">
                </label>
                <label>
                    Ground Color
                    <input type="color" id="hemisphere-ground-color" value="#664d33">
                </label>
                <label>
                    Intensity
                    <input type="range" id="hemisphere-intensity" min="0" max="2" step="0.1" value="0.5">
                    <span class="value" id="hemisphere-intensity-val">0.5</span>
                </label>
            </div>
            <hr class="divider">
            <div class="section">
                <h3>Skybox</h3>
                <label>
                    <input type="checkbox" id="skybox-enabled" checked>
                    Enable
                </label>
                <label>
                    Sky Color
                    <input type="color" id="skybox-sky-color" value="#6496e6">
                </label>
                <label>
                    Horizon Color
                    <input type="color" id="skybox-horizon-color" value="#c8d2dc">
                </label>
                <label>
                    Ground Color
                    <input type="color" id="skybox-ground-color" value="#322d28">
                </label>
                <label style="flex-direction: column; align-items: flex-start;">
                    HDR Environment
                    <input type="file" id="skybox-hdr-file" accept=".hdr,.env" style="display: block; font-size: 11px; margin-top: 4px; color: #888;">
                </label>
                <div id="hdr-loading" style="display: none; color: #888; font-size: 11px; margin-top: 4px;">Loading HDR...</div>
            </div>
            <hr class="divider">
            <div class="section">
                <h3>Shadows</h3>
                <label>
                    <input type="checkbox" id="shadows-enabled" checked>
                    Enable
                </label>
                <label>
                    Resolution
                    <select id="shadow-resolution">
                        <option value="512">512</option>
                        <option value="1024">1024</option>
                        <option value="2048" selected>2048</option>
                        <option value="4096">4096</option>
                    </select>
                </label>
                <label>
                    Filter
                    <select id="shadow-filter">
                        <option value="0">None</option>
                        <option value="1">PCF</option>
                        <option value="2" selected>PCSS</option>
                        <option value="3">Close ESM</option>
                    </select>
                </label>
                <label>
                    Bias
                    <input type="range" id="shadow-bias" min="0" max="0.05" step="0.001" value="0.005">
                    <span class="value" id="shadow-bias-val">0.005</span>
                </label>
                <label>
                    Darkness
                    <input type="range" id="shadow-darkness" min="0" max="1" step="0.05" value="0.5">
                    <span class="value" id="shadow-darkness-val">0.5</span>
                </label>
            </div>
        </div>

        <!-- Effects Tab -->
        <div class="tab-content" id="tab-effects">
            <div class="section">
                <h3>Depth of Field</h3>
                <label>
                    <input type="checkbox" id="dof-enabled">
                    Enable
                </label>
                <label>
                    Focus Dist
                    <input type="range" id="dof-focus-distance" min="0" max="50" step="0.5" value="10">
                    <span class="value" id="dof-focus-distance-val">10.0</span>
                </label>
                <label>
                    F-Stop
                    <input type="range" id="dof-fstop" min="0.5" max="22" step="0.5" value="2.8">
                    <span class="value" id="dof-fstop-val">2.8</span>
                </label>
                <label>
                    Focal Length
                    <input type="range" id="dof-focal-length" min="10" max="200" step="5" value="50">
                    <span class="value" id="dof-focal-length-val">50</span>
                </label>
            </div>
            <hr class="divider">
            <div class="section">
                <h3>Motion Blur</h3>
                <label>
                    <input type="checkbox" id="motion-blur-enabled">
                    Enable
                </label>
                <label>
                    Intensity
                    <input type="range" id="motion-blur-intensity" min="0" max="2" step="0.1" value="1.0">
                    <span class="value" id="motion-blur-intensity-val">1.0</span>
                </label>
            </div>
            <hr class="divider">
            <div class="section">
                <h3>Chromatic Aberration</h3>
                <label>
                    <input type="checkbox" id="chromatic-enabled">
                    Enable
                </label>
                <label>
                    Amount
                    <input type="range" id="chromatic-amount" min="0" max="100" step="5" value="30">
                    <span class="value" id="chromatic-amount-val">30</span>
                </label>
            </div>
            <hr class="divider">
            <div class="section">
                <h3>Grain</h3>
                <label>
                    <input type="checkbox" id="grain-enabled">
                    Enable
                </label>
                <label>
                    Amount
                    <input type="range" id="grain-amount" min="0" max="100" step="5" value="20">
                    <span class="value" id="grain-amount-val">20</span>
                </label>
            </div>
            <hr class="divider">
            <div class="section">
                <h3>Color Curves</h3>
                <label>
                    <input type="checkbox" id="curves-enabled">
                    Enable
                </label>
                <label>
                    Global Hue
                    <input type="range" id="curves-hue" min="-180" max="180" step="5" value="0">
                    <span class="value" id="curves-hue-val">0</span>
                </label>
                <label>
                    Global Saturation
                    <input type="range" id="curves-saturation" min="-100" max="100" step="5" value="0">
                    <span class="value" id="curves-saturation-val">0</span>
                </label>
                <label>
                    Global Density
                    <input type="range" id="curves-density" min="-100" max="100" step="5" value="0">
                    <span class="value" id="curves-density-val">0</span>
                </label>
            </div>
        </div>

        <!-- AA Tab -->
        <div class="tab-content" id="tab-aa">
            <div class="section">
                <h3>Anti-Aliasing</h3>
                <label>
                    Mode
                    <select id="aa-mode">
                        <option value="0">None</option>
                        <option value="1" selected>FXAA</option>
                    </select>
                </label>
            </div>
            <div class="section">
                <h3>Image Processing</h3>
                <label>
                    Contrast
                    <input type="range" id="contrast" min="0" max="2" step="0.05" value="1">
                    <span class="value" id="contrast-val">1.00</span>
                </label>
            </div>
            <hr class="divider">
            <div class="section">
                <h3>Sharpen</h3>
                <label>
                    <input type="checkbox" id="sharpen-enabled">
                    Enable
                </label>
                <label>
                    Amount
                    <input type="range" id="sharpen-amount" min="0" max="1" step="0.05" value="0.3">
                    <span class="value" id="sharpen-amount-val">0.30</span>
                </label>
            </div>
        </div>

        <!-- Scene Tab -->
        <div class="tab-content" id="tab-scene">
            <div class="section">
                <h3>SSAO</h3>
                <label>
                    <input type="checkbox" id="ssao-enabled" checked>
                    Enable
                </label>
                <label>
                    Radius
                    <input type="range" id="ssao-radius" min="0.01" max="2" step="0.01" value="0.5">
                    <span class="value" id="ssao-radius-val">0.50</span>
                </label>
                <label>
                    Total Strength
                    <input type="range" id="ssao-strength" min="0" max="2" step="0.05" value="1.0">
                    <span class="value" id="ssao-strength-val">1.00</span>
                </label>
                <label>
                    Base
                    <input type="range" id="ssao-base" min="0" max="1" step="0.05" value="0.5">
                    <span class="value" id="ssao-base-val">0.50</span>
                </label>
                <button id="ssao-reset" style="margin-top: 5px; padding: 5px 10px; background: #444; border: none; color: #fff; border-radius: 3px; cursor: pointer;">Reset SSAO</button>
            </div>
            <hr class="divider">
            <div class="section">
                <h3>Fog</h3>
                <label>
                    <input type="checkbox" id="fog-enabled">
                    Enable
                </label>
                <label>
                    Mode
                    <select id="fog-mode">
                        <option value="1">Linear</option>
                        <option value="2" selected>Exponential</option>
                        <option value="3">Exp Squared</option>
                    </select>
                </label>
                <label>
                    Density
                    <input type="range" id="fog-density" min="0" max="0.1" step="0.001" value="0.01">
                    <span class="value" id="fog-density-val">0.01</span>
                </label>
                <label>
                    Color
                    <input type="color" id="fog-color" value="#8899aa">
                </label>
            </div>
            <hr class="divider">
            <div class="section">
                <h3>IBL (Environment Lighting)</h3>
                <label>
                    Intensity
                    <input type="range" id="ibl-intensity" min="0" max="2" step="0.1" value="1.0">
                    <span class="value" id="ibl-intensity-val">1.0</span>
                </label>
            </div>
            <hr class="divider">
            <div class="section">
                <h3>Scene Lights</h3>
                <label>
                    Preset
                    <select id="light-preset">
                        <option value="studio" selected>Car Studio</option>
                        <option value="outdoor">Outdoor</option>
                        <option value="dramatic">Dramatic</option>
                    </select>
                </label>
                <div style="margin-top: 10px; font-size: 11px; color: #aaa;">Key Light</div>
                <label><input type="checkbox" id="light0-enabled" checked> Enable</label>
                <label>Intensity <input type="range" id="light0-intensity" min="0" max="30" step="1" value="15"><span class="value" id="light0-intensity-val">15</span></label>
                <label>Color <input type="color" id="light0-color" value="#fffaf2"></label>
                <label>X <input type="range" id="light0-x" min="-15" max="15" step="0.5" value="5"><span class="value" id="light0-x-val">5</span></label>
                <label>Y <input type="range" id="light0-y" min="0" max="20" step="0.5" value="8"><span class="value" id="light0-y-val">8</span></label>
                <label>Z <input type="range" id="light0-z" min="-15" max="15" step="0.5" value="5"><span class="value" id="light0-z-val">5</span></label>
                <div style="margin-top: 10px; font-size: 11px; color: #aaa;">Fill Light</div>
                <label><input type="checkbox" id="light1-enabled" checked> Enable</label>
                <label>Intensity <input type="range" id="light1-intensity" min="0" max="30" step="1" value="10"><span class="value" id="light1-intensity-val">10</span></label>
                <label>Color <input type="color" id="light1-color" value="#e6f2ff"></label>
                <label>X <input type="range" id="light1-x" min="-15" max="15" step="0.5" value="-5"><span class="value" id="light1-x-val">-5</span></label>
                <label>Y <input type="range" id="light1-y" min="0" max="20" step="0.5" value="6"><span class="value" id="light1-y-val">6</span></label>
                <label>Z <input type="range" id="light1-z" min="-15" max="15" step="0.5" value="3"><span class="value" id="light1-z-val">3</span></label>
                <div style="margin-top: 10px; font-size: 11px; color: #aaa;">Rim Light</div>
                <label><input type="checkbox" id="light2-enabled" checked> Enable</label>
                <label>Intensity <input type="range" id="light2-intensity" min="0" max="30" step="1" value="8"><span class="value" id="light2-intensity-val">8</span></label>
                <label>Color <input type="color" id="light2-color" value="#ffffff"></label>
                <label>X <input type="range" id="light2-x" min="-15" max="15" step="0.5" value="0"><span class="value" id="light2-x-val">0</span></label>
                <label>Y <input type="range" id="light2-y" min="0" max="20" step="0.5" value="4"><span class="value" id="light2-y-val">4</span></label>
                <label>Z <input type="range" id="light2-z" min="-15" max="15" step="0.5" value="-6"><span class="value" id="light2-z-val">-6</span></label>
                <div style="margin-top: 10px; font-size: 11px; color: #aaa;">Bounce Light</div>
                <label><input type="checkbox" id="light3-enabled" checked> Enable</label>
                <label>Intensity <input type="range" id="light3-intensity" min="0" max="30" step="1" value="5"><span class="value" id="light3-intensity-val">5</span></label>
                <label>Color <input type="color" id="light3-color" value="#ccd9e6"></label>
                <label>X <input type="range" id="light3-x" min="-15" max="15" step="0.5" value="-3"><span class="value" id="light3-x-val">-3</span></label>
                <label>Y <input type="range" id="light3-y" min="0" max="20" step="0.5" value="1"><span class="value" id="light3-y-val">1</span></label>
                <label>Z <input type="range" id="light3-z" min="-15" max="15" step="0.5" value="-3"><span class="value" id="light3-z-val">-3</span></label>
            </div>
            <hr class="divider">
            <div class="section">
                <h3>Transform Gizmo</h3>
                <label>
                    Mode
                    <select id="gizmo-mode">
                        <option value="0" selected>None</option>
                        <option value="1">Translate</option>
                        <option value="2">Rotate</option>
                        <option value="3">Scale</option>
                        <option value="4">Bounding Box</option>
                    </select>
                </label>
                <label>
                    <input type="checkbox" id="gizmo-local" checked>
                    Local Space
                </label>
                <div id="selected-mesh" style="font-size: 11px; color: #888; margin-top: 8px;">Selected: None</div>
                <button id="deselect-btn" style="margin-top: 5px; padding: 5px 10px; background: #444; border: none; color: #fff; border-radius: 3px; cursor: pointer;">Deselect</button>
            </div>
            <hr class="divider">
            <div class="section">
                <h3>Helpers</h3>
                <label>
                    <input type="checkbox" id="show-grid" checked>
                    Show Grid
                </label>
                <label>
                    <input type="checkbox" id="show-axes" checked>
                    Show Axes
                </label>
            </div>
        </div>
    </div>

    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>

    <script>
        // Tab switching
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                tab.classList.add('active');
                document.getElementById('tab-' + tab.dataset.tab).classList.add('active');
            });
        });

        // Main initialization
        window.addEventListener('DOMContentLoaded', async () => {
            const loadingEl = document.getElementById('loading');
            const errorEl = document.getElementById('error');
            const statsEl = document.getElementById('stats');
            const canvas = document.getElementById('canvas');

            // Helper functions
            function hexToRgb(hex) {
                const r = parseInt(hex.slice(1, 3), 16);
                const g = parseInt(hex.slice(3, 5), 16);
                const b = parseInt(hex.slice(5, 7), 16);
                return { r, g, b };
            }

            function hexToColor3(hex) {
                const rgb = hexToRgb(hex);
                return new BABYLON.Color3(rgb.r / 255, rgb.g / 255, rgb.b / 255);
            }

            try {
                // Create engine
                const engine = new BABYLON.Engine(canvas, true, {
                    preserveDrawingBuffer: true,
                    stencil: true,
                    antialias: true
                });

                // Create scene
                const scene = new BABYLON.Scene(engine);
                scene.clearColor = new BABYLON.Color4(0.1, 0.1, 0.12, 1);

                // Camera
                const camera = new BABYLON.ArcRotateCamera(
                    "camera",
                    Math.PI / 4,
                    Math.PI / 3,
                    10,
                    BABYLON.Vector3.Zero(),
                    scene
                );
                camera.attachControl(canvas, true);
                camera.wheelPrecision = 50;
                camera.minZ = 0.1;
                camera.maxZ = 1000;
                camera.lowerRadiusLimit = 1;
                camera.upperRadiusLimit = 100;
                camera.panningSensibility = 100;

                // ========== LIGHTS ==========

                // Hemisphere light
                const hemiLight = new BABYLON.HemisphericLight(
                    "hemiLight",
                    new BABYLON.Vector3(0, 1, 0),
                    scene
                );
                hemiLight.intensity = 0.5;
                hemiLight.diffuse = new BABYLON.Color3(0.6, 0.75, 1.0);
                hemiLight.groundColor = new BABYLON.Color3(0.4, 0.3, 0.2);

                // Directional light for shadows (sun)
                const dirLight = new BABYLON.DirectionalLight(
                    "dirLight",
                    new BABYLON.Vector3(-1, -2, -1).normalize(),
                    scene
                );
                dirLight.position = new BABYLON.Vector3(10, 20, 10);
                dirLight.intensity = 1.5;

                // Shadow generator
                let shadowGenerator = new BABYLON.ShadowGenerator(2048, dirLight);
                shadowGenerator.usePercentageCloserFiltering = true;
                shadowGenerator.filteringQuality = BABYLON.ShadowGenerator.QUALITY_HIGH;
                shadowGenerator.bias = 0.005;
                shadowGenerator.darkness = 0.5;

                // Point lights (4 studio lights)
                const pointLights = [];
                const lightConfigs = [
                    { pos: new BABYLON.Vector3(5, 8, 5), color: new BABYLON.Color3(1, 0.98, 0.95), intensity: 15 },
                    { pos: new BABYLON.Vector3(-5, 6, 3), color: new BABYLON.Color3(0.9, 0.95, 1), intensity: 10 },
                    { pos: new BABYLON.Vector3(0, 4, -6), color: new BABYLON.Color3(1, 1, 1), intensity: 8 },
                    { pos: new BABYLON.Vector3(-3, 1, -3), color: new BABYLON.Color3(0.8, 0.85, 0.9), intensity: 5 }
                ];

                for (let i = 0; i < 4; i++) {
                    const light = new BABYLON.PointLight(`pointLight${i}`, lightConfigs[i].pos, scene);
                    light.diffuse = lightConfigs[i].color;
                    light.intensity = lightConfigs[i].intensity;
                    light.range = 30;
                    pointLights.push(light);
                }

                // ========== SKYBOX ==========

                const skybox = BABYLON.MeshBuilder.CreateBox("skyBox", { size: 500 }, scene);
                const skyboxMaterial = new BABYLON.StandardMaterial("skyBoxMaterial", scene);
                skyboxMaterial.backFaceCulling = false;
                skyboxMaterial.disableLighting = true;
                skybox.material = skyboxMaterial;
                skybox.infiniteDistance = true;
                skybox.renderingGroupId = 0;

                // Dynamic texture for gradient skybox
                let skyGradientTexture = null;

                function updateSkyboxColors() {
                    const skyColor = hexToRgb(document.getElementById('skybox-sky-color').value);
                    const horizonColor = hexToRgb(document.getElementById('skybox-horizon-color').value);
                    const groundColor = hexToRgb(document.getElementById('skybox-ground-color').value);

                    if (skyGradientTexture) {
                        skyGradientTexture.dispose();
                    }

                    skyGradientTexture = new BABYLON.DynamicTexture("skyGradient", { width: 1, height: 256 }, scene, false);
                    const ctx = skyGradientTexture.getContext();
                    const gradient = ctx.createLinearGradient(0, 0, 0, 256);
                    gradient.addColorStop(0, `rgb(${skyColor.r}, ${skyColor.g}, ${skyColor.b})`);
                    gradient.addColorStop(0.45, `rgb(${horizonColor.r}, ${horizonColor.g}, ${horizonColor.b})`);
                    gradient.addColorStop(0.55, `rgb(${horizonColor.r}, ${horizonColor.g}, ${horizonColor.b})`);
                    gradient.addColorStop(1, `rgb(${groundColor.r}, ${groundColor.g}, ${groundColor.b})`);
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, 1, 256);
                    skyGradientTexture.update();

                    skyboxMaterial.emissiveTexture = skyGradientTexture;
                    skyboxMaterial.emissiveColor = new BABYLON.Color3(1, 1, 1);
                }
                updateSkyboxColors();

                // ========== GROUND ==========

                const ground = BABYLON.MeshBuilder.CreateGround("ground", { width: 20, height: 20 }, scene);
                const groundMat = new BABYLON.PBRMaterial("groundMat", scene);
                groundMat.albedoColor = new BABYLON.Color3(0.3, 0.3, 0.3);
                groundMat.metallic = 0;
                groundMat.roughness = 0.7;
                ground.material = groundMat;
                ground.receiveShadows = true;

                // ========== GRID ==========

                const gridLines = [];
                function createGrid() {
                    const gridSize = 20;
                    const gridDivisions = 20;
                    const step = gridSize / gridDivisions;

                    for (let i = -gridDivisions / 2; i <= gridDivisions / 2; i++) {
                        const pos = i * step;
                        const color = i === 0 ? new BABYLON.Color3(0.5, 0.5, 0.5) : new BABYLON.Color3(0.3, 0.3, 0.3);

                        const lineX = BABYLON.MeshBuilder.CreateLines(`gridX${i}`, {
                            points: [new BABYLON.Vector3(-gridSize / 2, 0.01, pos), new BABYLON.Vector3(gridSize / 2, 0.01, pos)]
                        }, scene);
                        lineX.color = color;
                        gridLines.push(lineX);

                        const lineZ = BABYLON.MeshBuilder.CreateLines(`gridZ${i}`, {
                            points: [new BABYLON.Vector3(pos, 0.01, -gridSize / 2), new BABYLON.Vector3(pos, 0.01, gridSize / 2)]
                        }, scene);
                        lineZ.color = color;
                        gridLines.push(lineZ);
                    }
                }
                createGrid();

                // ========== AXES ==========

                const axesLines = [];
                function createAxes() {
                    const axisLength = 3;
                    const axisX = BABYLON.MeshBuilder.CreateLines("axisX", {
                        points: [BABYLON.Vector3.Zero(), new BABYLON.Vector3(axisLength, 0, 0)]
                    }, scene);
                    axisX.color = new BABYLON.Color3(1, 0, 0);
                    axesLines.push(axisX);

                    const axisY = BABYLON.MeshBuilder.CreateLines("axisY", {
                        points: [BABYLON.Vector3.Zero(), new BABYLON.Vector3(0, axisLength, 0)]
                    }, scene);
                    axisY.color = new BABYLON.Color3(0, 1, 0);
                    axesLines.push(axisY);

                    const axisZ = BABYLON.MeshBuilder.CreateLines("axisZ", {
                        points: [BABYLON.Vector3.Zero(), new BABYLON.Vector3(0, 0, axisLength)]
                    }, scene);
                    axisZ.color = new BABYLON.Color3(0, 0, 1);
                    axesLines.push(axisZ);
                }
                createAxes();

                // ========== POST PROCESSING ==========

                const pipeline = new BABYLON.DefaultRenderingPipeline(
                    "defaultPipeline",
                    true,
                    scene,
                    [camera]
                );

                // Bloom
                pipeline.bloomEnabled = true;
                pipeline.bloomThreshold = 0.6;
                pipeline.bloomWeight = 0.8;
                pipeline.bloomKernel = 64;
                pipeline.bloomScale = 0.5;

                // FXAA
                pipeline.fxaaEnabled = true;

                // Image processing
                pipeline.imageProcessingEnabled = true;
                pipeline.imageProcessing.toneMappingEnabled = true;
                pipeline.imageProcessing.toneMappingType = BABYLON.ImageProcessingConfiguration.TONEMAPPING_ACES;
                pipeline.imageProcessing.exposure = 1.5;
                pipeline.imageProcessing.contrast = 1.0;

                // Vignette
                pipeline.imageProcessing.vignetteEnabled = true;
                pipeline.imageProcessing.vignetteWeight = 1.5;
                pipeline.imageProcessing.vignetteStretch = 0;
                pipeline.imageProcessing.vignetteColor = new BABYLON.Color4(0, 0, 0, 0);
                pipeline.imageProcessing.vignetteCameraFov = camera.fov;

                // ========== SSAO ==========

                let ssao = null;
                let ssaoEnabled = true;

                function createSSAO() {
                    if (ssao) {
                        ssao.dispose();
                    }
                    ssao = new BABYLON.SSAO2RenderingPipeline("ssao", scene, {
                        ssaoRatio: 0.5,
                        blurRatio: 0.5
                    }, [camera], true);
                    ssao.radius = 0.5;
                    ssao.totalStrength = 1.0;
                    ssao.base = 0.5;
                    ssao.samples = 16;
                    ssao.maxZ = 100;
                }
                createSSAO();

                // ========== LOADED MESHES ==========

                let loadedMeshes = [];

                // ========== DEMO SHAPES ==========

                function addDemoShapes() {
                    // Sphere
                    const sphere = BABYLON.MeshBuilder.CreateSphere("sphere", { diameter: 1.5, segments: 32 }, scene);
                    sphere.position = new BABYLON.Vector3(-2, 0.75, 0);
                    const sphereMat = new BABYLON.PBRMaterial("sphereMat", scene);
                    sphereMat.albedoColor = new BABYLON.Color3(0.8, 0.2, 0.2);
                    sphereMat.metallic = 0.9;
                    sphereMat.roughness = 0.1;
                    sphere.material = sphereMat;
                    shadowGenerator.addShadowCaster(sphere);
                    sphere.receiveShadows = true;
                    loadedMeshes.push(sphere);

                    // Box
                    const box = BABYLON.MeshBuilder.CreateBox("box", { size: 1.2 }, scene);
                    box.position = new BABYLON.Vector3(0, 0.6, 0);
                    const boxMat = new BABYLON.PBRMaterial("boxMat", scene);
                    boxMat.albedoColor = new BABYLON.Color3(0.2, 0.6, 0.2);
                    boxMat.metallic = 0.0;
                    boxMat.roughness = 0.5;
                    box.material = boxMat;
                    shadowGenerator.addShadowCaster(box);
                    box.receiveShadows = true;
                    loadedMeshes.push(box);

                    // Torus
                    const torus = BABYLON.MeshBuilder.CreateTorus("torus", { diameter: 1.2, thickness: 0.4, tessellation: 32 }, scene);
                    torus.position = new BABYLON.Vector3(2, 0.6, 0);
                    const torusMat = new BABYLON.PBRMaterial("torusMat", scene);
                    torusMat.albedoColor = new BABYLON.Color3(0.2, 0.4, 0.8);
                    torusMat.metallic = 0.5;
                    torusMat.roughness = 0.3;
                    torus.material = torusMat;
                    shadowGenerator.addShadowCaster(torus);
                    torus.receiveShadows = true;
                    loadedMeshes.push(torus);

                    // Cylinder
                    const cylinder = BABYLON.MeshBuilder.CreateCylinder("cylinder", { height: 1.5, diameter: 0.8, tessellation: 32 }, scene);
                    cylinder.position = new BABYLON.Vector3(0, 0.75, -2);
                    const cylMat = new BABYLON.PBRMaterial("cylMat", scene);
                    cylMat.albedoColor = new BABYLON.Color3(0.8, 0.6, 0.2);
                    cylMat.metallic = 0.7;
                    cylMat.roughness = 0.2;
                    cylinder.material = cylMat;
                    shadowGenerator.addShadowCaster(cylinder);
                    cylinder.receiveShadows = true;
                    loadedMeshes.push(cylinder);

                    // Knot
                    const knot = BABYLON.MeshBuilder.CreateTorusKnot("knot", { radius: 0.5, tube: 0.15, radialSegments: 128, tubularSegments: 32 }, scene);
                    knot.position = new BABYLON.Vector3(0, 1.2, 2);
                    const knotMat = new BABYLON.PBRMaterial("knotMat", scene);
                    knotMat.albedoColor = new BABYLON.Color3(0.7, 0.3, 0.7);
                    knotMat.metallic = 0.3;
                    knotMat.roughness = 0.4;
                    knot.material = knotMat;
                    shadowGenerator.addShadowCaster(knot);
                    knot.receiveShadows = true;
                    loadedMeshes.push(knot);

                    console.log('Added 5 demo shapes');
                }

                // Clear loaded meshes
                function clearMeshes() {
                    loadedMeshes.forEach(mesh => {
                        shadowGenerator.removeShadowCaster(mesh);
                        mesh.dispose();
                    });
                    loadedMeshes = [];
                    console.log('Cleared all models');
                }

                // ========== DAY/NIGHT CYCLE ==========

                let dayNightEnabled = false;
                let dayNightTime = 0.5;
                let dayNightSpeed = 1.0;

                function updateSunFromTime(time) {
                    const angle = time * Math.PI * 2 - Math.PI / 2;
                    const sunHeight = Math.sin(angle);
                    const sunHorizontal = Math.cos(angle);

                    const dirX = -sunHorizontal * 0.3;
                    const dirY = -Math.max(0.1, sunHeight);
                    const dirZ = -0.5;
                    const len = Math.sqrt(dirX * dirX + dirY * dirY + dirZ * dirZ);

                    dirLight.direction = new BABYLON.Vector3(dirX / len, dirY / len, dirZ / len);
                    dirLight.position = dirLight.direction.scale(-30);

                    // Adjust light intensity based on time
                    const dayFactor = Math.max(0, sunHeight);
                    dirLight.intensity = 0.3 + dayFactor * 1.7;

                    // Update sky colors based on time
                    let skyR, skyG, skyB, horizonR, horizonG, horizonB, groundR, groundG, groundB;

                    if (sunHeight < -0.1) {
                        // Night
                        skyR = 10; skyG = 15; skyB = 30;
                        horizonR = 20; horizonG = 25; horizonB = 40;
                        groundR = 5; groundG = 5; groundB = 10;
                        hemiLight.intensity = 0.15;
                    } else if (sunHeight < 0.3) {
                        // Sunrise/Sunset
                        const t = (sunHeight + 0.1) / 0.4;
                        skyR = Math.floor(10 + t * 120); skyG = Math.floor(15 + t * 80); skyB = Math.floor(30 + t * 60);
                        horizonR = Math.floor(200 + t * 55); horizonG = Math.floor(100 + t * 50); horizonB = Math.floor(50 + t * 100);
                        groundR = Math.floor(50 + t * 30); groundG = Math.floor(40 + t * 30); groundB = Math.floor(30 + t * 30);
                        hemiLight.intensity = 0.2 + t * 0.3;
                    } else {
                        // Day
                        const t = Math.min(1, (sunHeight - 0.3) / 0.7);
                        skyR = Math.floor(100 + t * 30); skyG = Math.floor(150 + t * 30); skyB = Math.floor(230);
                        horizonR = Math.floor(200 + t * 40); horizonG = Math.floor(220 + t * 30); horizonB = Math.floor(240);
                        groundR = 80; groundG = 70; groundB = 60;
                        hemiLight.intensity = 0.5;
                    }

                    // Update skybox colors dynamically
                    if (skyGradientTexture) {
                        const ctx = skyGradientTexture.getContext();
                        const gradient = ctx.createLinearGradient(0, 0, 0, 256);
                        gradient.addColorStop(0, `rgb(${skyR}, ${skyG}, ${skyB})`);
                        gradient.addColorStop(0.45, `rgb(${horizonR}, ${horizonG}, ${horizonB})`);
                        gradient.addColorStop(0.55, `rgb(${horizonR}, ${horizonG}, ${horizonB})`);
                        gradient.addColorStop(1, `rgb(${groundR}, ${groundG}, ${groundB})`);
                        ctx.fillStyle = gradient;
                        ctx.fillRect(0, 0, 1, 256);
                        skyGradientTexture.update();
                    }

                    // Update time display
                    const hours = Math.floor(time * 24);
                    const minutes = Math.floor((time * 24 - hours) * 60);
                    document.getElementById('daynight-time-val').textContent =
                        `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                }

                // Initial sun position
                updateSunFromTime(dayNightTime);

                // Add initial demo shapes
                addDemoShapes();
                loadingEl.style.display = 'none';

                // ========== RENDER LOOP ==========

                let frameCount = 0;
                let fps = 0;
                let lastStatTime = performance.now();
                let lastFrameTime = performance.now();

                engine.runRenderLoop(() => {
                    const currentTime = performance.now();
                    const deltaTime = (currentTime - lastFrameTime) / 1000;
                    lastFrameTime = currentTime;

                    // Day/night cycle update
                    if (dayNightEnabled) {
                        dayNightTime += deltaTime * dayNightSpeed * 0.01;
                        if (dayNightTime > 1) dayNightTime -= 1;
                        document.getElementById('daynight-time').value = dayNightTime;
                        updateSunFromTime(dayNightTime);
                    }

                    scene.render();
                    frameCount++;

                    // Update stats every second
                    if (currentTime - lastStatTime >= 1000) {
                        fps = frameCount;
                        frameCount = 0;
                        lastStatTime = currentTime;

                        const drawCalls = engine._drawCalls ? engine._drawCalls.current : 0;
                        const triangles = engine._activeRenderLoops ? scene.getActiveIndices() / 3 : 0;

                        statsEl.innerHTML = `
                            FPS: ${fps}<br>
                            Draw Calls: ${drawCalls}<br>
                            Triangles: ${Math.floor(triangles).toLocaleString()}<br>
                            Active Meshes: ${scene.getActiveMeshes().length}
                        `;
                    }
                });

                // Handle resize
                window.addEventListener('resize', () => {
                    engine.resize();
                });

                // ========== MODEL LOADING ==========

                document.getElementById('model-input').addEventListener('change', async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    console.log('Loading file:', file.name);

                    try {
                        const ext = file.name.split('.').pop().toLowerCase();
                        const url = URL.createObjectURL(file);

                        BABYLON.SceneLoader.ImportMesh("", "", url, scene, (meshes) => {
                            console.log(`Loaded ${meshes.length} mesh(es) from ${file.name}`);

                            meshes.forEach(mesh => {
                                if (mesh.getTotalVertices() > 0) {
                                    shadowGenerator.addShadowCaster(mesh);
                                    mesh.receiveShadows = true;
                                    loadedMeshes.push(mesh);
                                }
                            });

                            URL.revokeObjectURL(url);
                        }, null, (scene, message, exception) => {
                            console.error('Failed to load model:', message);
                            alert('Failed to load model: ' + message);
                            URL.revokeObjectURL(url);
                        }, "." + ext);

                    } catch (err) {
                        console.error('Failed to load model:', err);
                        alert('Failed to load model: ' + err.message);
                    }
                    e.target.value = '';
                });

                document.getElementById('clear-btn').addEventListener('click', () => {
                    clearMeshes();
                });

                document.getElementById('demo-btn').addEventListener('click', () => {
                    addDemoShapes();
                });

                // ========== DAY/NIGHT CONTROLS ==========

                document.getElementById('daynight-enabled').addEventListener('change', (e) => {
                    dayNightEnabled = e.target.checked;
                    document.getElementById('daynight-time').disabled = e.target.checked;
                });

                document.getElementById('daynight-speed').addEventListener('input', (e) => {
                    dayNightSpeed = parseFloat(e.target.value);
                    document.getElementById('daynight-speed-val').textContent = dayNightSpeed.toFixed(1);
                });

                document.getElementById('daynight-time').addEventListener('input', (e) => {
                    dayNightTime = parseFloat(e.target.value);
                    updateSunFromTime(dayNightTime);
                });

                // ========== BLOOM CONTROLS ==========

                document.getElementById('bloom-enabled').addEventListener('change', (e) => {
                    pipeline.bloomEnabled = e.target.checked;
                });

                document.getElementById('bloom-intensity').addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    pipeline.bloomWeight = val;
                    document.getElementById('bloom-intensity-val').textContent = val.toFixed(1);
                });

                document.getElementById('bloom-threshold').addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    pipeline.bloomThreshold = val;
                    document.getElementById('bloom-threshold-val').textContent = val.toFixed(2);
                });

                // ========== EXPOSURE/TONEMAPPING ==========

                document.getElementById('exposure').addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    pipeline.imageProcessing.exposure = val;
                    document.getElementById('exposure-val').textContent = val.toFixed(1);
                });

                document.getElementById('tonemap-operator').addEventListener('change', (e) => {
                    const val = parseInt(e.target.value);
                    pipeline.imageProcessing.toneMappingEnabled = val > 0;
                    if (val === 1) pipeline.imageProcessing.toneMappingType = BABYLON.ImageProcessingConfiguration.TONEMAPPING_STANDARD;
                    else if (val >= 2) pipeline.imageProcessing.toneMappingType = BABYLON.ImageProcessingConfiguration.TONEMAPPING_ACES;
                });

                // ========== VIGNETTE ==========

                document.getElementById('vignette-enabled').addEventListener('change', (e) => {
                    pipeline.imageProcessing.vignetteEnabled = e.target.checked;
                });

                document.getElementById('vignette-weight').addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    pipeline.imageProcessing.vignetteWeight = val;
                    document.getElementById('vignette-weight-val').textContent = val.toFixed(1);
                });

                // ========== HEMISPHERE LIGHT ==========

                document.getElementById('hemisphere-enabled').addEventListener('change', (e) => {
                    hemiLight.setEnabled(e.target.checked);
                });

                document.getElementById('hemisphere-sky-color').addEventListener('input', (e) => {
                    hemiLight.diffuse = hexToColor3(e.target.value);
                });

                document.getElementById('hemisphere-ground-color').addEventListener('input', (e) => {
                    hemiLight.groundColor = hexToColor3(e.target.value);
                });

                document.getElementById('hemisphere-intensity').addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    hemiLight.intensity = val;
                    document.getElementById('hemisphere-intensity-val').textContent = val.toFixed(1);
                });

                // ========== SKYBOX ==========

                document.getElementById('skybox-enabled').addEventListener('change', (e) => {
                    skybox.setEnabled(e.target.checked);
                });

                document.getElementById('skybox-sky-color').addEventListener('input', updateSkyboxColors);
                document.getElementById('skybox-horizon-color').addEventListener('input', updateSkyboxColors);
                document.getElementById('skybox-ground-color').addEventListener('input', updateSkyboxColors);

                // HDR Environment
                document.getElementById('skybox-hdr-file').addEventListener('change', async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    const hdrLoading = document.getElementById('hdr-loading');
                    hdrLoading.style.display = 'block';
                    hdrLoading.textContent = 'Loading HDR...';

                    try {
                        const url = URL.createObjectURL(file);

                        const hdrTexture = BABYLON.CubeTexture.CreateFromPrefilteredData(url, scene);
                        scene.environmentTexture = hdrTexture;

                        skyboxMaterial.reflectionTexture = hdrTexture.clone();
                        skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
                        skyboxMaterial.emissiveTexture = null;
                        skyboxMaterial.emissiveColor = new BABYLON.Color3(0, 0, 0);

                        hdrLoading.textContent = 'HDR loaded: ' + file.name;
                        setTimeout(() => { hdrLoading.style.display = 'none'; }, 2000);
                    } catch (err) {
                        hdrLoading.textContent = 'Error loading HDR';
                        console.error('HDR load error:', err);
                    }
                });

                // ========== SHADOWS ==========

                document.getElementById('shadows-enabled').addEventListener('change', (e) => {
                    if (e.target.checked) {
                        dirLight.shadowEnabled = true;
                        ground.receiveShadows = true;
                    } else {
                        dirLight.shadowEnabled = false;
                        ground.receiveShadows = false;
                    }
                });

                document.getElementById('shadow-resolution').addEventListener('change', (e) => {
                    const size = parseInt(e.target.value);
                    const map = shadowGenerator.getShadowMap();
                    if (map) {
                        map.resize(size);
                    }
                });

                document.getElementById('shadow-filter').addEventListener('change', (e) => {
                    const val = parseInt(e.target.value);
                    shadowGenerator.useExponentialShadowMap = false;
                    shadowGenerator.usePercentageCloserFiltering = false;
                    shadowGenerator.useContactHardeningShadow = false;
                    shadowGenerator.useBlurExponentialShadowMap = false;

                    if (val === 0) {
                        // None - basic shadows
                    } else if (val === 1) {
                        shadowGenerator.usePercentageCloserFiltering = true;
                    } else if (val === 2) {
                        shadowGenerator.useContactHardeningShadow = true;
                    } else if (val === 3) {
                        shadowGenerator.useBlurExponentialShadowMap = true;
                    }
                });

                document.getElementById('shadow-bias').addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    shadowGenerator.bias = val;
                    document.getElementById('shadow-bias-val').textContent = val.toFixed(3);
                });

                document.getElementById('shadow-darkness').addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    shadowGenerator.darkness = val;
                    document.getElementById('shadow-darkness-val').textContent = val.toFixed(2);
                });

                // ========== RENDER MODE ==========

                let originalMaterials = new Map();

                document.getElementById('render-mode').addEventListener('change', (e) => {
                    const mode = parseInt(e.target.value);

                    // Reset wireframe
                    scene.forceWireframe = false;

                    // Restore original materials if switching back to lit
                    if (mode === 0) {
                        originalMaterials.forEach((mat, mesh) => {
                            mesh.material = mat;
                        });
                        originalMaterials.clear();
                    }

                    scene.meshes.forEach(mesh => {
                        if (mesh === skybox || mesh === ground || gridLines.includes(mesh) || axesLines.includes(mesh)) return;
                        if (!mesh.material) return;

                        if (mode === 0) {
                            // Lit - restore
                        } else if (mode === 1) {
                            // Unlit
                            if (!originalMaterials.has(mesh)) {
                                originalMaterials.set(mesh, mesh.material);
                            }
                            const mat = new BABYLON.StandardMaterial("unlit_" + mesh.name, scene);
                            mat.emissiveColor = mesh.material.albedoColor || new BABYLON.Color3(0.5, 0.5, 0.5);
                            mat.disableLighting = true;
                            mesh.material = mat;
                        } else if (mode === 2) {
                            // Normals
                            if (!originalMaterials.has(mesh)) {
                                originalMaterials.set(mesh, mesh.material);
                            }
                            const mat = new BABYLON.NormalMaterial("normal_" + mesh.name, scene);
                            mesh.material = mat;
                        } else if (mode === 3) {
                            // Depth - use a simple gradient based on distance
                            if (!originalMaterials.has(mesh)) {
                                originalMaterials.set(mesh, mesh.material);
                            }
                            const mat = new BABYLON.StandardMaterial("depth_" + mesh.name, scene);
                            mat.emissiveColor = new BABYLON.Color3(1, 1, 1);
                            mat.disableLighting = true;
                            mesh.material = mat;
                        } else if (mode === 4) {
                            // Wireframe
                            scene.forceWireframe = true;
                        }
                    });
                });

                // ========== DOF ==========

                document.getElementById('dof-enabled').addEventListener('change', (e) => {
                    pipeline.depthOfFieldEnabled = e.target.checked;
                    if (e.target.checked) {
                        pipeline.depthOfFieldBlurLevel = BABYLON.DepthOfFieldEffectBlurLevel.Medium;
                    }
                });

                document.getElementById('dof-focus-distance').addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    pipeline.depthOfField.focusDistance = val * 1000;
                    document.getElementById('dof-focus-distance-val').textContent = val.toFixed(1);
                });

                document.getElementById('dof-fstop').addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    pipeline.depthOfField.fStop = val;
                    document.getElementById('dof-fstop-val').textContent = val.toFixed(1);
                });

                document.getElementById('dof-focal-length').addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    pipeline.depthOfField.focalLength = val;
                    document.getElementById('dof-focal-length-val').textContent = val.toFixed(0);
                });

                // ========== MOTION BLUR ==========

                let motionBlur = null;

                document.getElementById('motion-blur-enabled').addEventListener('change', (e) => {
                    if (e.target.checked) {
                        if (!motionBlur) {
                            motionBlur = new BABYLON.MotionBlurPostProcess("motionBlur", scene, 1.0, camera);
                            motionBlur.motionStrength = parseFloat(document.getElementById('motion-blur-intensity').value);
                        }
                    } else {
                        if (motionBlur) {
                            motionBlur.dispose();
                            motionBlur = null;
                        }
                    }
                });

                document.getElementById('motion-blur-intensity').addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    if (motionBlur) motionBlur.motionStrength = val;
                    document.getElementById('motion-blur-intensity-val').textContent = val.toFixed(1);
                });

                // ========== CHROMATIC ABERRATION ==========

                document.getElementById('chromatic-enabled').addEventListener('change', (e) => {
                    pipeline.chromaticAberrationEnabled = e.target.checked;
                });

                document.getElementById('chromatic-amount').addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    pipeline.chromaticAberration.aberrationAmount = val;
                    document.getElementById('chromatic-amount-val').textContent = val.toFixed(0);
                });

                // ========== GRAIN ==========

                document.getElementById('grain-enabled').addEventListener('change', (e) => {
                    pipeline.grainEnabled = e.target.checked;
                });

                document.getElementById('grain-amount').addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    pipeline.grain.intensity = val;
                    document.getElementById('grain-amount-val').textContent = val.toFixed(0);
                });

                // ========== COLOR CURVES ==========

                document.getElementById('curves-enabled').addEventListener('change', (e) => {
                    pipeline.imageProcessing.colorCurvesEnabled = e.target.checked;
                    if (e.target.checked && !pipeline.imageProcessing.colorCurves) {
                        pipeline.imageProcessing.colorCurves = new BABYLON.ColorCurves();
                    }
                });

                document.getElementById('curves-hue').addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    if (!pipeline.imageProcessing.colorCurves) {
                        pipeline.imageProcessing.colorCurves = new BABYLON.ColorCurves();
                    }
                    pipeline.imageProcessing.colorCurves.globalHue = val;
                    document.getElementById('curves-hue-val').textContent = val.toFixed(0);
                });

                document.getElementById('curves-saturation').addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    if (!pipeline.imageProcessing.colorCurves) {
                        pipeline.imageProcessing.colorCurves = new BABYLON.ColorCurves();
                    }
                    pipeline.imageProcessing.colorCurves.globalSaturation = val;
                    document.getElementById('curves-saturation-val').textContent = val.toFixed(0);
                });

                document.getElementById('curves-density').addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    if (!pipeline.imageProcessing.colorCurves) {
                        pipeline.imageProcessing.colorCurves = new BABYLON.ColorCurves();
                    }
                    pipeline.imageProcessing.colorCurves.globalDensity = val;
                    document.getElementById('curves-density-val').textContent = val.toFixed(0);
                });

                // ========== AA ==========

                document.getElementById('aa-mode').addEventListener('change', (e) => {
                    const mode = parseInt(e.target.value);
                    pipeline.fxaaEnabled = mode === 1;
                });

                document.getElementById('contrast').addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    pipeline.imageProcessing.contrast = val;
                    document.getElementById('contrast-val').textContent = val.toFixed(2);
                });

                // ========== SHARPEN ==========

                document.getElementById('sharpen-enabled').addEventListener('change', (e) => {
                    pipeline.sharpenEnabled = e.target.checked;
                });

                document.getElementById('sharpen-amount').addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    pipeline.sharpen.edgeAmount = val;
                    document.getElementById('sharpen-amount-val').textContent = val.toFixed(2);
                });

                // ========== SSAO CONTROLS ==========

                document.getElementById('ssao-enabled').addEventListener('change', (e) => {
                    ssaoEnabled = e.target.checked;
                    if (ssao) {
                        if (e.target.checked) {
                            scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline("ssao", camera);
                        } else {
                            scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline("ssao", camera);
                        }
                    }
                });

                document.getElementById('ssao-radius').addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    if (ssao) ssao.radius = val;
                    document.getElementById('ssao-radius-val').textContent = val.toFixed(2);
                });

                document.getElementById('ssao-strength').addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    if (ssao) ssao.totalStrength = val;
                    document.getElementById('ssao-strength-val').textContent = val.toFixed(2);
                });

                document.getElementById('ssao-base').addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    if (ssao) ssao.base = val;
                    document.getElementById('ssao-base-val').textContent = val.toFixed(2);
                });

                document.getElementById('ssao-reset').addEventListener('click', () => {
                    if (ssao) {
                        ssao.radius = 0.5;
                        ssao.totalStrength = 1.0;
                        ssao.base = 0.5;
                    }
                    document.getElementById('ssao-radius').value = 0.5;
                    document.getElementById('ssao-radius-val').textContent = '0.50';
                    document.getElementById('ssao-strength').value = 1.0;
                    document.getElementById('ssao-strength-val').textContent = '1.00';
                    document.getElementById('ssao-base').value = 0.5;
                    document.getElementById('ssao-base-val').textContent = '0.50';
                });

                // ========== FOG ==========

                document.getElementById('fog-enabled').addEventListener('change', (e) => {
                    if (e.target.checked) {
                        scene.fogMode = parseInt(document.getElementById('fog-mode').value);
                        scene.fogDensity = parseFloat(document.getElementById('fog-density').value);
                        scene.fogColor = hexToColor3(document.getElementById('fog-color').value);
                        scene.fogStart = 10;
                        scene.fogEnd = 100;
                    } else {
                        scene.fogMode = BABYLON.Scene.FOGMODE_NONE;
                    }
                });

                document.getElementById('fog-mode').addEventListener('change', (e) => {
                    if (document.getElementById('fog-enabled').checked) {
                        scene.fogMode = parseInt(e.target.value);
                    }
                });

                document.getElementById('fog-density').addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    scene.fogDensity = val;
                    document.getElementById('fog-density-val').textContent = val.toFixed(3);
                });

                document.getElementById('fog-color').addEventListener('input', (e) => {
                    scene.fogColor = hexToColor3(e.target.value);
                });

                // ========== IBL ==========

                document.getElementById('ibl-intensity').addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    scene.environmentIntensity = val;
                    document.getElementById('ibl-intensity-val').textContent = val.toFixed(1);
                });

                // ========== LIGHT PRESETS ==========

                const lightPresets = {
                    studio: [
                        { pos: [5, 8, 5], color: '#fffaf2', intensity: 15 },
                        { pos: [-5, 6, 3], color: '#e6f2ff', intensity: 10 },
                        { pos: [0, 4, -6], color: '#ffffff', intensity: 8 },
                        { pos: [-3, 1, -3], color: '#ccd9e6', intensity: 5 }
                    ],
                    outdoor: [
                        { pos: [10, 15, 5], color: '#fffbe6', intensity: 20 },
                        { pos: [-8, 8, 8], color: '#b3d9ff', intensity: 8 },
                        { pos: [0, 3, -10], color: '#e6e6e6', intensity: 5 },
                        { pos: [-5, 2, 5], color: '#99cc99', intensity: 3 }
                    ],
                    dramatic: [
                        { pos: [8, 10, 0], color: '#ff9966', intensity: 25 },
                        { pos: [-10, 5, 5], color: '#6699ff', intensity: 5 },
                        { pos: [0, 2, -8], color: '#333333', intensity: 2 },
                        { pos: [0, 15, 0], color: '#ffffff', intensity: 3 }
                    ]
                };

                document.getElementById('light-preset').addEventListener('change', (e) => {
                    const preset = lightPresets[e.target.value];
                    if (!preset) return;

                    preset.forEach((config, i) => {
                        pointLights[i].position = new BABYLON.Vector3(...config.pos);
                        pointLights[i].diffuse = hexToColor3(config.color);
                        pointLights[i].intensity = config.intensity;

                        document.getElementById(`light${i}-x`).value = config.pos[0];
                        document.getElementById(`light${i}-x-val`).textContent = config.pos[0];
                        document.getElementById(`light${i}-y`).value = config.pos[1];
                        document.getElementById(`light${i}-y-val`).textContent = config.pos[1];
                        document.getElementById(`light${i}-z`).value = config.pos[2];
                        document.getElementById(`light${i}-z-val`).textContent = config.pos[2];
                        document.getElementById(`light${i}-color`).value = config.color;
                        document.getElementById(`light${i}-intensity`).value = config.intensity;
                        document.getElementById(`light${i}-intensity-val`).textContent = config.intensity;
                    });
                });

                // ========== INDIVIDUAL LIGHT CONTROLS ==========

                for (let i = 0; i < 4; i++) {
                    document.getElementById(`light${i}-enabled`).addEventListener('change', (e) => {
                        pointLights[i].setEnabled(e.target.checked);
                    });

                    document.getElementById(`light${i}-intensity`).addEventListener('input', (e) => {
                        const val = parseFloat(e.target.value);
                        pointLights[i].intensity = val;
                        document.getElementById(`light${i}-intensity-val`).textContent = val;
                    });

                    document.getElementById(`light${i}-color`).addEventListener('input', (e) => {
                        pointLights[i].diffuse = hexToColor3(e.target.value);
                    });

                    ['x', 'y', 'z'].forEach(axis => {
                        document.getElementById(`light${i}-${axis}`).addEventListener('input', (e) => {
                            const val = parseFloat(e.target.value);
                            const pos = pointLights[i].position.clone();
                            if (axis === 'x') pos.x = val;
                            else if (axis === 'y') pos.y = val;
                            else pos.z = val;
                            pointLights[i].position = pos;
                            document.getElementById(`light${i}-${axis}-val`).textContent = val;
                        });
                    });
                }

                // ========== TRANSFORM GIZMO ==========

                const gizmoManager = new BABYLON.GizmoManager(scene);
                gizmoManager.positionGizmoEnabled = false;
                gizmoManager.rotationGizmoEnabled = false;
                gizmoManager.scaleGizmoEnabled = false;
                gizmoManager.boundingBoxGizmoEnabled = false;
                gizmoManager.usePointerToAttachGizmos = false; // We'll handle selection manually

                let selectedMesh = null;

                function updateGizmoMode() {
                    const mode = parseInt(document.getElementById('gizmo-mode').value);

                    gizmoManager.positionGizmoEnabled = mode === 1;
                    gizmoManager.rotationGizmoEnabled = mode === 2;
                    gizmoManager.scaleGizmoEnabled = mode === 3;
                    gizmoManager.boundingBoxGizmoEnabled = mode === 4;

                    if (selectedMesh && mode > 0) {
                        gizmoManager.attachToMesh(selectedMesh);
                    } else {
                        gizmoManager.attachToMesh(null);
                    }
                }

                function selectMesh(mesh) {
                    selectedMesh = mesh;
                    const mode = parseInt(document.getElementById('gizmo-mode').value);

                    if (mesh) {
                        document.getElementById('selected-mesh').textContent = 'Selected: ' + mesh.name;
                        if (mode > 0) {
                            gizmoManager.attachToMesh(mesh);
                        }
                    } else {
                        document.getElementById('selected-mesh').textContent = 'Selected: None';
                        gizmoManager.attachToMesh(null);
                    }
                }

                // Click to select mesh
                scene.onPointerObservable.add((pointerInfo) => {
                    if (pointerInfo.type === BABYLON.PointerEventTypes.POINTERDOWN) {
                        if (pointerInfo.event.button === 0) { // Left click
                            const pickResult = scene.pick(scene.pointerX, scene.pointerY);

                            if (pickResult.hit && pickResult.pickedMesh) {
                                const mesh = pickResult.pickedMesh;

                                // Don't select ground, skybox, grid, or axes
                                if (mesh !== ground &&
                                    mesh !== skybox &&
                                    !gridLines.includes(mesh) &&
                                    !axesLines.includes(mesh)) {
                                    selectMesh(mesh);
                                }
                            }
                        }
                    }
                });

                document.getElementById('gizmo-mode').addEventListener('change', updateGizmoMode);

                document.getElementById('gizmo-local').addEventListener('change', (e) => {
                    const isLocal = e.target.checked;
                    if (gizmoManager.gizmos.positionGizmo) {
                        gizmoManager.gizmos.positionGizmo.updateGizmoRotationToMatchAttachedMesh = isLocal;
                    }
                    if (gizmoManager.gizmos.rotationGizmo) {
                        gizmoManager.gizmos.rotationGizmo.updateGizmoRotationToMatchAttachedMesh = isLocal;
                    }
                    if (gizmoManager.gizmos.scaleGizmo) {
                        gizmoManager.gizmos.scaleGizmo.updateGizmoRotationToMatchAttachedMesh = isLocal;
                    }
                });

                document.getElementById('deselect-btn').addEventListener('click', () => {
                    selectMesh(null);
                });

                // ========== HELPERS ==========

                document.getElementById('show-grid').addEventListener('change', (e) => {
                    gridLines.forEach(line => line.setEnabled(e.target.checked));
                });

                document.getElementById('show-axes').addEventListener('change', (e) => {
                    axesLines.forEach(line => line.setEnabled(e.target.checked));
                });

                console.log('Babylon.js engine initialized successfully');

            } catch (err) {
                loadingEl.style.display = 'none';
                errorEl.style.display = 'block';
                errorEl.textContent = 'Error: ' + err.message;
                console.error('Initialization error:', err);
            }
        });
    </script>
</body>
</html>
